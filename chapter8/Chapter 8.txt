8.0 Scheduling: The Multi-Level Feedback Queue
- The Multi-level Feedback Queue (MLFQ) tries to optimize turnaround time and response time without knowing how long a process will run.
- MLFQ is an example of a system that learns from the past to predict the future.
  - It works when jobs have phases of behavior which make them predictable.
  - Such techniques can lead to worse decisions than not knowing anything at all. One must be careful.

8.1 MLFQ: Basic Rules
- The specifics of many MLFQ implementations differ but most approaches are similar.
- There are distinc queues with a different priority level. A job that is ready to run is on a single queue.
  - The priorities are used to decide which job to run. A job with higher priority (on a queue with higher priority) is chosen to run.
  - If there are multiple jobs on a queue, round-robin scheduling is used among them.
  => Rule 1: If Priority(A) > Priority(B), A runs (B does not).
  => Rule 2: If Priority(A) = Priority(B), A & B run in RR.
- Priorites of job are varied based on their behavior observed. They are not fixed.
  - If a job repeatedly does not use the CPU as it is waiting for keyboard input, its priority is kept high.
  - If a job uses the CPU intensively for long periods of time, its priority is reduced.
  - MLFQ uses the history of the job to learn about it and predict its future behaviour.

8.2 Attempt #1: How To Change Priority
- Workload: A mix of interative short-running jobs and longer-running CPU-intensive jobs.
- The priority of a job will be changed based on its allotment: The amount of time a job can spend at a given priority level before it is reduced by the scheduler. For simplicity, the allotment will be equal to a single time slice:
  => Rule 3: When a job enters the system, it is placed at the highest priority.
  => Rule 4a: If a job uses up its allotment while running, its priority is reduced.
  => Rule 4b: If a job gives up the CPU before the allotment is up, it stays at the same priority level. Its allotment is reset.
- Example 1: A Single Long-Running Job
  - A long-running job with a time slice and allotment to 10 ms will have its priority reduced every 10 ms.
  - In a three-queue scheduler, it enters at the highest queue and will end up in the lowest queue after 20 ms.
- Example 2: Along Came A Short Job


